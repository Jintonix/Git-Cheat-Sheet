\chapter{Rebasing}
\chapteroverlay
\section{What is Rebasing?}
Think of git rebase as lifting your commits off your current branch and then replaying them one by one on top of a new base (in our case, the updated main).

- main has new commits from person A.

- You are working on a feature branch that has commits of its own.

- Rebase takes your commits, temporarily removes them, updates your branch to look like main.

- Then tries to apply your commits on top, as if you branched off after person A's changes were already made.

This gives you a clean, linear history.\\

When you run \gitinline{git rebase main}, Git takes all your commits (from where your branch diverged from main) and replays them one by one on top of the updated main.

If Git tries applying a commit that touched a file that also changed in main, you get a conflict.

Once you fix it and \gitinline{git rebase --continue}, Git will move on to the next commit, and so on, until it finally reapplies your most recent work.

So:

You’re not “losing” your latest changes — they just haven’t been replayed yet.

You’ll resolve conflicts in the order your commits were originally made.

At the end of the rebase, your branch will contain all your commits, sitting neatly on top of the updated main.

\begin{gitBashBox}
push --force-with-lease 
\end{gitBashBox}
must be used afterwards, because the new commit history is different than the one on the remote after rebasing.